Assignment name   : get_next_line
Expected files    : get_next_line.c get_next_line.h
Allowed functions : read, free, malloc
--------------------------------------------------------------------------------

Escriba una función llamada get_next_line cuyo prototipo debe ser:
char *get_next_line(int fd);

Tu función debe devolver una línea que ha sido leída desde el descriptor de
fichero pasado como parámetro.

Lo que llamamos una "línea que ha sido leída" es una sucesión de 0 a n
caracteres que terminan con '\n' (código ascii 0x0a) o con End Of File (EOF).

Se debe devolver la línea incluyendo el '\n' en caso de que haya uno al final
de la línea que se ha leído.

Cuando ha alcanzado el EOF, debe almacenar el buffer actual en un char * y
devolverlo. Si el buffer está vacío debe devolver NULL.

En caso de error devuelve NULL.

En caso de no devolver NULL, el puntero debe ser free-able.

Tu programa será compilado con el flag -D BUFFER_SIZE=xx, que debe ser
usado como tamaño del buffer para las llamadas de lectura en tus funciones.

Tu función debe estar libre de fugas de memoria.

Cuando haya alcanzado el EOF, su función debe mantener 0 memoria asignada con
malloc excepto la línea que ha sido devuelta.

Llamar a tu función get_next_line en un bucle te permitirá por tanto leer
el texto disponible en un descriptor de fichero línea a línea hasta el final
del texto, sin importar el tamaño del texto o de una de sus líneas.

Asegúrese de que su función se comporta bien cuando lee de un fichero, de la
salida estándar, de una redirección, etc.

No se realizará ninguna llamada a otra función en el descriptor de fichero entre
2 llamadas de get_next_line.

Finalmente consideramos que get_next_line tiene un comportamiento indefinido al
leer desde un fichero binario.

Deberías usar el test.sh para ayudarte a probar tu get_next_line.



--------------------------------------------------------------------------------
Write a function named get_next_line which prototype should be:
char    *get_next_line(int fd);

Your function must return a line that has been read from the file descriptor
passed as parameter.

What we call a "line that has been read" is a succession of 0 to n characters
that end with '\n' (ascii code 0x0a) or with End Of File (EOF).

The line should be returned including the '\n' in case there is one at the end
of the line that has been read.

When you've reached the EOF, you must store the current buffer in a char * and
return it. If the buffer is empty you must return NULL.

In case of error return NULL.

In case of not returning NULL, the pointer should be free-able.

Your program will be compiled with the flag -D BUFFER_SIZE=xx, which has to be
used as the buffer size for the read calls in your functions.

Your function must be memory leak free.

When you've reached the EOF, your function should keep 0 memory allocated with
malloc except the line that has been returned.

Calling your function get_next_line in a loop will therefore allow you to read
the text available on a file descriptor one line at a time until the end of the
text, no matter the size of either the text or one of its lines.

Make sure that your function behaves well when it reads from a file, from the
standard output, from a redirection etc.

No call to another function will be done on the file descriptor between 2 calls
of get_next_line.

Finally we consider that get_next_line has an undefined behavior when reading
from a binary file.

You should use the test.sh to help you test your get_next_line.
